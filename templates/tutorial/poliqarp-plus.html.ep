% content main => begin

<h2>KorAP-Tutorial: Poliqarp+</h2>

<p><%= korap_tut_link_to 'Back to Index', '/tutorial' %></p>

<p>The following tutorial introduces all features provided by our version of the Poliqarp Query Language and some KorAP specific extensions.</p>

<section id="tut-segments">
<h3>Simple Segments</h3>

<p>The atomic elements of Poliqarp queries are segments. Most of the time segments represent words and can be simply queried:</p>
%# footnote: In the polish national corpus, Poliqarp can join multiple segments when identifying a single word.

%= korap_tut_query poliqarp => 'Baum'

<p>Sequences of simple segments are expressed using a space delimiter:</p>

%= korap_tut_query poliqarp => 'der Baum'

<p>Simple segments always refer to the surface form of a word. To search for surface forms without case sensitivity, you can use the <code>/i</code> flag.</p>

%= korap_tut_query poliqarp => 'laufen/i'

<p>The query above will find all occurrences of <code>laufen</code> irrespective of the capitalization of letters, so <code>wir laufen</code> will be find as well as <code>das Laufen</code> and even <code>&quot;GEH LAUFEN!&quot;</code>.
</section>

<section id="tut-regexp">
  <h3>Regular Expressions</h3>

<p>Segments can also be queried using <%= korap_tut_link_to 'regular expressions', '/tutorial/regular-expressions' %> - by surrounding the segment with double quotes.</p>

%= korap_tut_query poliqarp => '"l(au|ie)fen"'

<p>Regular expression segments will always match the whole segment, meaning the above query will find words starting with <code>l</code> and ending with <code>n</code>. To support subqueries, you can use the <code>/x</code> flag.

%= korap_tut_query poliqarp => '"l(au|ie)fen"/x', cutoff => 1

<p>The <code>/x</code> will search for all segments that contain a sequence of characters the regular expression matches. That means the above query is equivalent to:</p>

%= korap_tut_query poliqarp => '".*?l(au|ie)fen.*?"', cutoff => 1

<p>The <code>/x</code> flag can also be used in conjuntion with strict expressions to search for substrings:</p>

%= korap_tut_query poliqarp => 'trenn/xi', cutoff => 1

<p>The above query will find all occurrences of segments including the string <code>trenn</code> case insensitive, like &quot;Trennung&quot;, &quot;unzertrennlich&quot;, or &quot;Wettrennen&quot;.</p>

<blockquote class="warning">
  <p>Beware: These kinds of queries (with prepended <code>.*</code> expressions) are extremely slow!</p>
</blockquote>

<p>You can again apply the <code>/i</code> flag to search case insensitive.</p>

%= korap_tut_query poliqarp => '"l(au|ie)fen"/xi', cutoff => 1

</section>

<section id="tut-complex">
  <h3>Complex Segments</h3>

<p>Complex segments are expressed in square brackets and contain additional information on the resource of the term under scrutiny by providing key/value pairs, separated by a <code>=</code> symbol.</p>

<p>The KorAP implementation of Poliqarp provides three special segment keys: <code>orth</code> for surface forms, <code>base</code> for lemmata, and <code>pos</code> for Part-of-Speech. The following complex query finds all surface forms of <code>Baum</code>.</p>

%# There are more special keys in Poliqarp, but KorAP doesn't provide them.

%= korap_tut_query poliqarp => '[orth=Baum]'

<p>The query is thus equivalent to:</p>

%= korap_tut_query poliqarp => 'Baum'

<p>Complex segments expect simple expressions as a values, meaning that the following expression is valid as well:</p>

%= korap_tut_query poliqarp => '[orth="l(au|ie)fen"/xi]', cutoff => 1

<p>Another special key is <code>base</code>, refering to the lemma annotation of the <%= korap_tut_link_to 'default foundry', '/tutorial/foundries' %>. The following query finds all occurrences of segments annotated as the lemma <code>Baum</code> by the default foundry.</p>

%= korap_tut_query poliqarp => '[base=baum]'

<p>The third special key is <code>pos</code>, refering to the part-of-speech annotation of the <%= korap_tut_link_to 'default foundry', '/tutorial/foundries' %>. The following query finds all attributive adjectives:</p>

%= korap_tut_query poliqarp => '[pos=ADJA]'

<p>Complex segments requesting further token annotations can have keys following the <code>foundry/layer</code> notation. For example to find all occurrences of plural words in the mate foundry, you can search using the following query:</p>

%= korap_tut_query poliqarp => '[mate/m=number:pl]'

<blockquote class="warning">
  <p>There is currently a bug in the serialization of this query.</p>
  <p><strong>The following stuff in the tutorial is not yet tested.</strong></p>
</blockquote>

</section>

<section id="tut-spans">
<h3>Span Segments</h3>

%= korap_tut_query poliqarp => '<s>'

</section>

<section id="tut-paradigmatic-operators">
<h3>Paradigmatic Operators</h3>
%= korap_tut_query poliqarp => '[orth=laufe/i & base=lauf]'

%= korap_tut_query poliqarp => '[orth=laufe/i & base!=lauf]'

<blockquote class="warning">
  <p>There is a bug in the Lucene backend regarding the negation of matches</p>
</blockquote>

<p>The following query is equivalent</p>

%= korap_tut_query poliqarp => '[orth=bäume & !base=bäumen]'

<p>Some more ...</p>

%= korap_tut_query poliqarp => '[base=laufen | base=gehen]'

%= korap_tut_query poliqarp => '[(base=laufen | base=gehen) & tt/pos=VVFIN]'

%= korap_tut_query poliqarp => '[]'

</section>

<section id="tut-syntagmatic-operators">
<h3>Syntagmatic Operators</h3>

<h4>Sequences</h4>

<h4>Repetition</h4>
%= korap_tut_query poliqarp => '[base=der][][base=Baum]'

%= korap_tut_query poliqarp => '[base=der][]{2}[base=Baum]'
%= korap_tut_query poliqarp => '[base=der][]{2,3}[base=Baum]'
%= korap_tut_query poliqarp => '[base=der][]{2,}[base=Baum]'
%= korap_tut_query poliqarp => '[base=der][]{,3}[base=Baum]'

%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]?[base=Baum]'
%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]*[base=Baum]'
%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]+[base=Baum]'

<h4>Alternation</h4>

<h4>Position Operators</h4>

<p>contains()</p>
<p>startsWith()</p>
<p>endsWith()</p>
<p>overlaps()</p>

<blockquote>
  <p>The KorAP implementation of Poliqarp also support the postfix <code>within</code> operator, that works similar to the <code>contains()</code>, but is not nestable.</p>
</blockquote>

<h4>Class Operators</h4>

<p>{}</p>
<p>focus()</p>
<p>...</p>

</section>

% end
