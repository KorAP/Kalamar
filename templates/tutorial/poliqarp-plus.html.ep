% content main => begin

<h2>KorAP-Tutorial: Poliqarp+</h2>

<p><%= korap_tut_link_to 'Back to Index', '/tutorial' %></p>

<p>The following tutorial introduces all features provided by our version of the Poliqarp Query Language and some KorAP specific extensions.</p>

<section id="tut-segments">
<h3>Simple Segments</h3>

<p>The atomic elements of Poliqarp queries are segments. Most of the time segments represent words and can be simply queried:</p>
%# footnote: In the polish national corpus, Poliqarp can join multiple segments when identifying a single word.

%= korap_tut_query poliqarp => 'Baum'

<p>Sequences of simple segments are expressed using a space delimiter:</p>

%= korap_tut_query poliqarp => 'der Baum'

<p>Simple segments always refer to the surface form of a word. To search for surface forms without case sensitivity, you can use the <code>/i</code> flag.</p>

%= korap_tut_query poliqarp => 'laufen/i'

<p>The query above will find all occurrences of <code>laufen</code> irrespective of the capitalization of letters, so <code>wir laufen</code> will be find as well as <code>das Laufen</code> and even <code>&quot;GEH LAUFEN!&quot;</code>.
</section>

<section id="tut-regexp">
  <h3>Regular Expressions</h3>

<p>Segments can also be queried using <%= korap_tut_link_to 'regular expressions', '/tutorial/regular-expressions' %> - by surrounding the segment with double quotes.</p>

%= korap_tut_query poliqarp => '"l(au|ie)fen"'

<p>Regular expression segments will always match the whole segment, meaning the above query will find words starting with <code>l</code> and ending with <code>n</code>. To support subqueries, you can use the <code>/x</code> flag.

%= korap_tut_query poliqarp => '"l(au|ie)fen"/x', cutoff => 1

<p>The <code>/x</code> will search for all segments that contain a sequence of characters the regular expression matches. That means the above query is equivalent to:</p>

%= korap_tut_query poliqarp => '".*?l(au|ie)fen.*?"', cutoff => 1

<p>The <code>/x</code> flag can also be used in conjuntion with strict expressions to search for substrings:</p>

%= korap_tut_query poliqarp => 'trenn/xi', cutoff => 1

<p>The above query will find all occurrences of segments including the string <code>trenn</code> case insensitive, like &quot;Trennung&quot;, &quot;unzertrennlich&quot;, or &quot;Wettrennen&quot;.</p>

<blockquote class="warning">
  <p>Beware: These kinds of queries (with prepended <code>.*</code> expressions) are extremely slow!</p>
</blockquote>

<p>You can again apply the <code>/i</code> flag to search case insensitive.</p>

%= korap_tut_query poliqarp => '"l(au|ie)fen"/xi', cutoff => 1

</section>

<section id="tut-complex">
  <h3>Complex Segments</h3>

<p>Complex segments are expressed in square brackets and contain additional information on the resource of the term under scrutiny by providing key/value pairs, separated by a <code>=</code> symbol.</p>

<p>The KorAP implementation of Poliqarp provides three special segment keys: <code>orth</code> for surface forms, <code>base</code> for lemmata, and <code>pos</code> for Part-of-Speech. The following complex query finds all surface forms of <code>Baum</code>.</p>

%# There are more special keys in Poliqarp, but KorAP doesn't provide them.

%= korap_tut_query poliqarp => '[orth=Baum]'

<p>The query is thus equivalent to:</p>

%= korap_tut_query poliqarp => 'Baum'

<p>Complex segments expect simple expressions as a values, meaning that the following expression is valid as well:</p>

%= korap_tut_query poliqarp => '[orth="l(au|ie)fen"/xi]', cutoff => 1

<p>Another special key is <code>base</code>, refering to the lemma annotation of the <%= korap_tut_link_to 'default foundry', '/tutorial/foundries' %>. The following query finds all occurrences of segments annotated as the lemma <code>Baum</code> by the default foundry.</p>

%= korap_tut_query poliqarp => '[base=baum]'

<p>The third special key is <code>pos</code>, refering to the part-of-speech annotation of the <%= korap_tut_link_to 'default foundry', '/tutorial/foundries' %>. The following query finds all attributive adjectives:</p>

%= korap_tut_query poliqarp => '[pos=ADJA]'

<p>Complex segments requesting further token annotations can have keys following the <code>foundry/layer</code> notation. For example to find all occurrences of plural words in the mate foundry, you can search using the following query:</p>

%= korap_tut_query poliqarp => '[mate/m=number:pl]'

<blockquote class="warning">
  <p><strong>The following queries in the tutorial are not yet tested and may not work.</strong></p>
</blockquote>

</section>

<section id="tut-spans">
<h3>Span Segments</h3>

%= korap_tut_query poliqarp => '<s>'

</section>

<section id="tut-paradigmatic-operators">
<h3>Paradigmatic Operators</h3>

<p>A complex segment can have multiple properties a token has to fulfill. For example to search for all words with the surface form <code>laufe</code> (no matter if capitalized or not) that have the lemma <code>lauf</code> (and not, for example, <code>laufen</code>, which would indicate a verb or a gerund), you can search for:</p>

%= korap_tut_query poliqarp => '[orth=laufe/i & base=lauf]'

<p>The ampersand combines multiple properties with a logical AND.</p>

%= korap_tut_query poliqarp => '[orth=laufe/i & base!=lauf]'

<blockquote class="warning">
  <p>There is a bug in the Lucene backend regarding the negation of matches</p>
</blockquote>

<p>The following query is equivalent</p>

%= korap_tut_query poliqarp => '[orth=bäume & !base=bäumen]'

<p>Some more ...</p>

%= korap_tut_query poliqarp => '[base=laufen | base=gehen]'

%= korap_tut_query poliqarp => '[(base=laufen | base=gehen) & tt/pos=VVFIN]'

%= korap_tut_query poliqarp => '[]'

</section>

<section id="tut-syntagmatic-operators">
<h3>Syntagmatic Operators</h3>

<h4>Sequences</h4>

<h4>Groups</h4>

<h4>Alternation</h4>

<p>Alternations allow for searching alternative segments or sequences of segments, similar to the paradigmatic operator. You already have seen that you can search for both sequences of <code>der alte Mann</code> and <code>der junge Mann</code> by typing in:</p>

%= korap_tut_query poliqarp => 'der [orth=alte | orth=junge] Mann'

<p>However, this formulation has problems in case you want to search for alternations of sequences rather than terms. If you want to search for both sequences of <code>dem jungen Mann</code> and <code>der alte Mann</code> you can use syntagmatic alternations and groups:</p>

%= korap_tut_query poliqarp => '(dem jungen | der alte) Mann'

<p>The pipe symbol works the same way as with the paradigmatic alternation, but supports sequences of different length as operands. The above query for <code>der alte Mann</code> and <code>der junge Mann</code> can therefor be reformulated as:</p>

%= korap_tut_query poliqarp => 'der (junge | alte) Mann'

<h4>Repetition</h4>

<p>Repetitions in Poliqarp are realized as in <%= korap_tut_link_to 'regular expressions', '/tutorial/regular-expressions' %>, by giving quantifieres in curly brackets.</p>
<p>To search for a sequence of three occurrences of <code>der</code>, you can formulate your query in any of the following ways - they will have the same results:</p>

%= korap_tut_query poliqarp => 'der der der'
%= korap_tut_query poliqarp => 'der{3}'
%= korap_tut_query poliqarp => '[orth=der]{3}'

<p>In difference to regular expressions, the repetition operation won't refer to the match but to the pattern given. So the following query will give you a sequence of three words having the term <code>der</code> as a substring - but the words don't have to be identical. The following query for example will match a sequence of three words all starting with <code>la</code>.</p>

%= korap_tut_query poliqarp => '"la.*?"/i{3}'

<p>The same is true for annotations. The following query will find a sequence of 3 to 4 adjectives as annotated by the TreeTagger foundry, that is preceded by the lemma <code>ein</code> as annotated by the default foundry and followed by a noun as annotated by the XIP foundry. The adjectives do not have to be identical though.</p>

%= korap_tut_query poliqarp => '[base=ein][tt/p=ADJA]{3,4}[xip/p=NOUN]'

<p>In addition to numbered quantities, it is also possible to pass repetition information as Kleene operators <code>?</code>, <code>+</code>, and <code>+</code>.</p>

<p>To search for a sequence of the lemma <code>der</code> followed by the lemma <code>baum</code> as annotated by the base foundry, but allowing an optional adjective as annotated by the TreeTagger foundry in between, you can search for:</p>

%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]?[base=baum]'

<p>This query is identical to the numbered quantification of:</p>

%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]{,1}[base=baum]'

<p>To search for the same sequences but with unlimited adjectives as annotated by the TreeTagger foundry in between, you can use the Kleene Star:</p>

%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]*[base=baum]'

<p>And to search for this sequence but with at least one adjective in between, you can use the Kleene Plus (all queries are identical):</p>

%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]+[base=baum]'
%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]{1,}[base=baum]'
%= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA][tt/pos=ADJA]*[base=baum]'

<blockquote class="warning">
  <p>Repetition operators like <code>{,4}</code>, <code>?</code>, and <code>*</code> make segments or groups of segments optional. In case these queries are used separated (and there are no mandatory segments in the query), you will be warned by the system that your query won't be treated as optional. Keep in mind that optionality may be somehow <i>inherited</i>, for example when you search for <code>(junge|alte)?|tote</code>, one segment of the alternation is optional, which makes the whole query optional as well.</p>
</blockquote>

%#= korap_tut_query poliqarp => '[base=der][][base=Baum]'
%#= korap_tut_query poliqarp => '[base=der][]{2}[base=Baum]'
%#= korap_tut_query poliqarp => '[base=der][]{2,}[base=Baum]'
%#= korap_tut_query poliqarp => '[base=der][]{,3}[base=Baum]'

%#= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]*[base=Baum]'
%#= korap_tut_query poliqarp => '[base=der][tt/pos=ADJA]+[base=Baum]'

<h4>Position</h4>

%#= korap_tut_query poliqarp => 'matches(<s>,[])'
%# matches(<s>,[cnx/p=INTERJ]{2})
<p>contains()</p>
<p>startsWith()</p>
<p>endsWith()</p>
<p>overlaps()</p>

<blockquote class="warning">
  <p>Optional operands in position operators, like in <code>within(&lt;s&gt;,[orth=Baum]*)</code>, have to be mandatory at the moment and will be reformulated to occur at least once.</p>
  <p>This behaviour may change in the future.</p>
</blockquote>

<blockquote>
  <p>The KorAP implementation of Poliqarp also supports the postfix <code>within</code> operator, that works similar to the <code>contains()</code> operator, but is not nestable.</p>
</blockquote>

<h4>Class Operators</h4>

<p>{}</p>
<p>focus()</p>
<p>...</p>

</section>

% end
